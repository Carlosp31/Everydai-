<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/dash.css') }}">
    <title>Welcome to EverydAI</title>

</head>
<body>
    <button id="openModalButton">User Guide</button>
    <div class="container">
        
        <div class="main-title">Welcome to EverydAI</div>
        <div class="sub-title">Choose a domain to continue</div>

        <!-- Contenedor del modelo 3D -->
        <div id="avatar-container"></div>
        
        <div class="option-container">
            <a href="{{ url_for('chat', domain='Cooking') }}" class="option"><i>üçΩÔ∏è</i> Cooking</a>
            <a href="{{ url_for('chat', domain='fashion') }}" class="option"><i>üëî</i> Fashion</a>
            <a href="{{ url_for('chat', domain='Fitness') }}" class="option"><i>üèÉ</i> Fitness</a>
        </div>
       
    <!-- Scripts de Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>

    <script>
document.getElementById('openModalButton').addEventListener('click', function() {
    Swal.fire({
        title: 'User Guide',
        html: `
            <p>Welcome to EverydAI user guide. Here you can:</p>
            <ul>
                <li>Select the domain for your daily activities.</li>
                <li>Talk with the avatars to receive help on your daily tasks.</li>
                <li>Receive information based on the elements you share to our avatars.</li>
            </ul>
        `,
        icon: 'info',
        confirmButtonText: 'Close'
    });
});


// Crear la escena y la c√°mara
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, 500 / 500, 0.1, 1000);
camera.position.z = 2.5; // Colocar la c√°mara a cierta distancia

// Configurar el renderizador
const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
renderer.setSize(1000, 1000);
document.getElementById("avatar-container").appendChild(renderer.domElement);

// A√±adir luces a la escena
const ambientLight = new THREE.AmbientLight(0xffffff, 1.5); // Aumentar la intensidad de la luz ambiental
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2); // Aumentar la intensidad de la luz direccional
directionalLight.position.set(1, 1, 1).normalize();
scene.add(directionalLight);

// Cargar el primer modelo 3D (avatar1) - avatar en la escena
const loader = new THREE.GLTFLoader();
let model1;

loader.load('{{ url_for("static", filename="models/avatar3.glb") }}', function(gltf) {
    model1 = gltf.scene;
    scene.add(model1);
    model1.position.set(0, 0, 0);
    // Asegurarse de que el avatar est√© mirando hacia la c√°mara
    model1.rotation.y = 0;
    model1.rotation.x = 0;

        // Aplicar morph targets al rostro
        model1.traverse((child) => {
        if (child.isMesh && child.name === 'Wolf3D_Head') {
            const morphs = {
                browInnerUp: 0.17,
                eyeSquintLeft: 0.4,
                eyeSquintRight: 0.44,
                noseSneerLeft: 0.17,
                noseSneerRight: 0.14,
                mouthPressLeft: 0.61,
                mouthPressRight: 0.41
            };

            Object.keys(morphs).forEach((key) => {
                if (child.morphTargetDictionary[key] !== undefined) {
                    child.morphTargetInfluences[child.morphTargetDictionary[key]] = morphs[key];
                }
            });
        }
    });


// Cargar la animaci√≥n desde animationschef.glb para avatar1
let animations1;
const animationLoader1 = new THREE.GLTFLoader();
animationLoader1.load('{{ url_for("static", filename="animations/animationsfashion.glb") }}', function(gltf) {
    animations1 = gltf.animations;

    // Buscar la animaci√≥n llamada "pose"
    const poseAnimation = animations1.find(animation => animation.name === "pose");

    if (poseAnimation) {
        // Eliminar las pistas de posici√≥n de la animaci√≥n
        poseAnimation.tracks = poseAnimation.tracks.filter(track => !track.name.includes('.position'));

        // Crear un Action de animaci√≥n y reproducirla
        const mixer = new THREE.AnimationMixer(model1);  // Usamos model1 porque es el que tiene el avatar
        const action = mixer.clipAction(poseAnimation);
        action.fadeIn(0.5).play();

        // Animar la escena con la animaci√≥n
        function animate() {
            requestAnimationFrame(animate);
            mixer.update(0.01);  // Actualizar la animaci√≥n
            renderer.render(scene, camera);
        }
        animate();
    }
});
});
// Cargar el segundo modelo 3D (avatar2) y su animaci√≥n (animationsgym.glb)
let model2;

loader.load('{{ url_for("static", filename="models/avatar2.glb") }}', function(gltf) {
    model2 = gltf.scene;
    scene.add(model2);
    model2.position.set(1.2, 0, 0);
    model2.rotation.y = 0;
    model2.rotation.x = 0;

    // Aplicar morph targets al rostro
    model2.traverse((child) => {
        if (child.isMesh && child.name === 'Wolf3D_Head') {
            const morphs = {
                browInnerUp: 0.17,
                eyeSquintLeft: 0.4,
                eyeSquintRight: 0.44,
                noseSneerLeft: 0.17,
                noseSneerRight: 0.14,
                mouthPressLeft: 0.61,
                mouthPressRight: 0.41
            };

            Object.keys(morphs).forEach((key) => {
                if (child.morphTargetDictionary[key] !== undefined) {
                    child.morphTargetInfluences[child.morphTargetDictionary[key]] = morphs[key];
                }
            });
        }
    });

    // Cargar la animaci√≥n desde animationsgym.glb
    let animations2;
    const animationLoader2 = new THREE.GLTFLoader();
    animationLoader2.load('{{ url_for("static", filename="animations/animationsgym.glb") }}', function(gltf) {
        animations2 = gltf.animations;

        // Buscar la animaci√≥n llamada "pose"
        const gymAnimation = animations2.find(animation => animation.name === "pose");

        if (gymAnimation) {
            // Eliminar las pistas de posici√≥n de la animaci√≥n
            gymAnimation.tracks = gymAnimation.tracks.filter(track => !track.name.includes('.position'));

            // Crear un Action de animaci√≥n y reproducirla
            const mixer = new THREE.AnimationMixer(model2);
            const action = mixer.clipAction(gymAnimation);
            action.fadeIn(0.5).play();

            // Animar la escena con la animaci√≥n
            function animate() {
                requestAnimationFrame(animate);
                mixer.update(0.01);
                renderer.render(scene, camera);
            }
            animate();
        }
    });
});


// Cargar el tercer modelo 3D (avatar3) y su animaci√≥n (animationsfashion.glb)
let model3;

loader.load('{{ url_for("static", filename="models/avatar1.glb") }}', function(gltf) {
    model3 = gltf.scene;
    scene.add(model3);
    model3.position.set(-1.2, 0, 0);
    model3.rotation.y = 0;
    model3.rotation.x = 0;
    // Aplicar morph targets al rostro
    model3.traverse((child) => {
        if (child.isMesh && child.name === 'Wolf3D_Head') {
            const morphs = {
                browInnerUp: 0.17,
                eyeSquintLeft: 0.4,
                eyeSquintRight: 0.44,
                noseSneerLeft: 0.17,
                noseSneerRight: 0.14,
                mouthPressLeft: 0.61,
                mouthPressRight: 0.41
            };

            Object.keys(morphs).forEach((key) => {
                if (child.morphTargetDictionary[key] !== undefined) {
                    child.morphTargetInfluences[child.morphTargetDictionary[key]] = morphs[key];
                }
            });
        }
    });
    // Cargar la animaci√≥n desde animationsfashion.glb
    let animations3;
    const animationLoader3 = new THREE.GLTFLoader();
    animationLoader3.load('{{ url_for("static", filename="animations/animationschef.glb") }}', function(gltf) {
        animations3 = gltf.animations;

        // Buscar la animaci√≥n llamada "pose" (o la animaci√≥n que deseas aplicar)
        const fashionAnimation = animations3.find(animation => animation.name === "dash_pose");

        if (fashionAnimation) {
            // Eliminar las pistas de posici√≥n de la animaci√≥n
            fashionAnimation.tracks = fashionAnimation.tracks.filter(track => !track.name.includes('.position'));

            // Crear un Action de animaci√≥n y reproducirla
            const mixer = new THREE.AnimationMixer(model3);  // Usamos model3 porque es el avatar3
            const action = mixer.clipAction(fashionAnimation);
            action.fadeIn(0.5).play();

            // Animar la escena con la animaci√≥n
            function animate() {
                requestAnimationFrame(animate);
                mixer.update(0.01);  // Actualizar la animaci√≥n
                renderer.render(scene, camera);
            }
            animate();
        }
    });
});

// Variables para el control del mouse
let isMouseDown = false;
let previousMousePosition = { x: 0, y: 0 };

document.addEventListener('mousedown', (event) => {
    isMouseDown = true;
    previousMousePosition.x = event.clientX;
    previousMousePosition.y = event.clientY;
});

document.addEventListener('mousemove', (event) => {
    if (!isMouseDown) return;

    const deltaX = event.clientX - previousMousePosition.x;
    const deltaY = event.clientY - previousMousePosition.y;

    if (model1) model1.rotation.y += deltaX * 0.01;
    if (model2) model2.rotation.y += deltaX * 0.01;
    if (model3) model3.rotation.y += deltaX * 0.01;

    previousMousePosition.x = event.clientX;
    previousMousePosition.y = event.clientY;
});

document.addEventListener('mouseup', () => {
    isMouseDown = false;
});


    </script>
</body>
</html>